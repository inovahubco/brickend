"""
test_api_integration.py
"""

import shutil
import sys
import traceback

import pytest
from typer.testing import CliRunner
from fastapi.testclient import TestClient
import ruamel.yaml

from brickend_cli.main import app as cli_app


def create_correct_entities_yaml(project_dir):
    """
    Create entities.yaml with the exact structure that ContextBuilder expects
    """
    entities_data = {
        "entities": [
            {
                "name": "User",  # ContextBuilder uses this as original_name
                "fields": [
                    {
                        "name": "id",
                        "type": "uuid",  # ContextBuilder maps this to UUID in TYPE_MAPPING
                        "primary_key": True,
                        "unique": True,
                        "nullable": False
                    },
                    {
                        "name": "email",
                        "type": "string",  # ContextBuilder maps this to VARCHAR
                        "primary_key": False,
                        "unique": True,
                        "nullable": False
                    },
                    {
                        "name": "full_name",
                        "type": "string",
                        "primary_key": False,
                        "unique": False,
                        "nullable": False
                    }
                ]
            }
        ]
    }

    yaml_handler = ruamel.yaml.YAML()
    entities_file = project_dir / "entities.yaml"

    with open(entities_file, "w", encoding="utf-8") as f:
        yaml_handler.dump(entities_data, f)

    print("Entities.yaml created correctly for ContextBuilder")
    return entities_file


def test_context_builder():
    """
    Test to verify that ContextBuilder works correctly
    """
    try:
        from brickend_core.templates.context_builder import ContextBuilder

        entities_dict = {
            "entities": [
                {
                    "name": "User",
                    "fields": [
                        {
                            "name": "id",
                            "type": "uuid",
                            "primary_key": True,
                            "unique": True,
                            "nullable": False
                        },
                        {
                            "name": "email",
                            "type": "string",
                            "primary_key": False,
                            "unique": True,
                            "nullable": False
                        }
                    ]
                }
            ]
        }

        builder = ContextBuilder()
        context = builder.build_context(entities_dict)

        print("Context generated by ContextBuilder:")
        print(f"  - entities count: {context.get('entity_count')}")
        print(f"  - first entity names: {context['entities'][0]['names']}")
        print(f"  - first field: {context['entities'][0]['fields'][0]}")

        return context

    except ImportError as e:
        print(f"Could not import ContextBuilder: {e}")
        return None
    except Exception as e:
        print(f"Error testing ContextBuilder: {e}")
        traceback.print_exc()
        return None


def create_manual_fastapi_project(project_dir):
    """
    Create a FastAPI project manually
    """
    print("Creating FastAPI project manually...")

    # Create directory structure
    app_dir = project_dir / "app"
    app_dir.mkdir(exist_ok=True)

    # Create __init__.py files
    (app_dir / "__init__.py").write_text("", encoding='utf-8')

    # app/database.py
    database_content = '''from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.pool import StaticPool

SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,  # StaticPool ensures single connection in memory
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
'''
    (app_dir / "database.py").write_text(database_content, encoding='utf-8')

    # app/main.py
    main_content = '''from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy.orm import Session
from sqlalchemy import Column, String
from pydantic import BaseModel, ConfigDict
from typing import List
import uuid

from app.database import engine, SessionLocal, Base

# Models
class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    full_name = Column(String, nullable=False)

# Schemas
class UserCreate(BaseModel):
    email: str
    full_name: str

class UserResponse(BaseModel):
    id: str
    email: str
    full_name: str
    
    model_config = ConfigDict(from_attributes=True)

# Database dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# FastAPI app
app = FastAPI(title="Demo App", version="1.0.0")

# Create tables
Base.metadata.create_all(bind=engine)

# CRUD Operations
def get_user(db: Session, user_id: str):
    return db.query(User).filter(User.id == user_id).first()

def get_users(db: Session, skip: int = 0, limit: int = 100):
    return db.query(User).offset(skip).limit(limit).all()

def create_user(db: Session, user: UserCreate):
    db_user = User(
        id=str(uuid.uuid4()),
        email=user.email,
        full_name=user.full_name
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: str):
    db_user = get_user(db, user_id)
    if db_user:
        db.delete(db_user)
        db.commit()
    return db_user

# Routes
@app.post("/users/", response_model=UserResponse)
def create_user_endpoint(user: UserCreate, db: Session = Depends(get_db)):
    # Check if user already exists
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    return create_user(db=db, user=user)

@app.get("/users/", response_model=List[UserResponse])
def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    users = get_users(db, skip=skip, limit=limit)
    return users

@app.get("/users/{user_id}", response_model=UserResponse)
def read_user(user_id: str, db: Session = Depends(get_db)):
    db_user = get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.delete("/users/{user_id}", response_model=UserResponse)
def delete_user_endpoint(user_id: str, db: Session = Depends(get_db)):
    db_user = delete_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.get("/")
def read_root():
    return {"message": "Welcome to Demo App!"}
'''
    (app_dir / "main.py").write_text(main_content, encoding='utf-8')

    print("FastAPI project created manually")
    return app_dir / "main.py"


@pytest.fixture
def project(tmp_path, monkeypatch):
    """
    Create a temporary Brickend project
    """
    runner = CliRunner()

    monkeypatch.chdir(tmp_path)

    print("Testing ContextBuilder...")
    _ = test_context_builder()

    print("Executing brickend init...")
    result_init = runner.invoke(cli_app, ["init", "project", "demo_app", "--type", "fastapi"])

    print(f"Init output: {result_init.stdout}")
    if result_init.stderr:
        print(f"Init stderr: {result_init.stderr}")

    if result_init.exit_code != 0:
        print("Init failed, creating basic project...")
        proj_dir = tmp_path / "demo_app"
        proj_dir.mkdir()
        monkeypatch.chdir(proj_dir)
        main_file = create_manual_fastapi_project(proj_dir)
        return proj_dir

    proj_dir = tmp_path / "demo_app"
    monkeypatch.chdir(proj_dir)

    print("Creating entities.yaml...")
    entities_file = create_correct_entities_yaml(proj_dir)

    with open(entities_file, "r", encoding="utf-8") as f:
        content = f.read()
        print(f"entities.yaml content:\n{content}")

    output_dir = proj_dir / "output"

    print("Executing brickend generate...")
    try:
        result_gen = runner.invoke(
            cli_app,
            [
                "generate", "code",
                "entities.yaml",
                "--output", str(output_dir),
                "--integration", "fastapi"
            ],
            catch_exceptions=False
        )

        print(f"Generate output: {result_gen.stdout}")
        if result_gen.stderr:
            print(f"Generate stderr: {result_gen.stderr}")

        if result_gen.exit_code == 0:
            print("Generate successful!")

            if output_dir.exists():
                print("Generated files:")
                for item in output_dir.rglob("*"):
                    if item.is_file():
                        print(f"  - {item.relative_to(output_dir)}")

                for item in output_dir.iterdir():
                    dest = proj_dir / item.name
                    if dest.exists():
                        if dest.is_dir():
                            shutil.rmtree(dest)
                        else:
                            dest.unlink()
                    shutil.move(str(item), str(dest))

                output_dir.rmdir()

        else:
            print("Generate failed, using manual project")
            main_file = create_manual_fastapi_project(proj_dir)

    except Exception as e:
        print(f"Exception in generate: {e}")
        traceback.print_exc()
        _ = create_manual_fastapi_project(proj_dir)

    print("Final project structure:")
    for item in proj_dir.rglob("*"):
        if item.is_file():
            print(f"  - {item.relative_to(proj_dir)}")

    return proj_dir


def test_crud_endpoints(project):
    """
    Test CRUD endpoints
    """
    print(f"\nStarting CRUD tests in {project}")

    # Clean up any existing test database file
    test_db_file = project / "test_app.db"
    if test_db_file.exists():
        test_db_file.unlink()
        print(f"ğŸ§¹ Cleaned up existing test database: {test_db_file}")

    possible_main_files = [
        project / "app" / "main.py",
        project / "main.py"
    ]

    main_file = None
    for possible_file in possible_main_files:
        if possible_file.exists():
            main_file = possible_file
            print(f"Found: {main_file}")
            break

    if not main_file:
        pytest.fail(f"No main.py found in: {possible_main_files}")

    project_str = str(project)
    main_dir_str = str(main_file.parent)

    if project_str not in sys.path:
        sys.path.insert(0, project_str)
    if main_dir_str not in sys.path:
        sys.path.insert(0, main_dir_str)

    try:
        if main_file.parent.name == "app":
            from app.main import app
        else:
            from main import app
        print("App imported successfully")
    except ImportError as e:
        pytest.fail(f"Could not import app: {e}")

    from fastapi import FastAPI
    assert isinstance(app, FastAPI), f"App is not FastAPI: {type(app)}"

    client = TestClient(app)

    try:
        print("\nExecuting CRUD tests...")

        # 1. Create user
        print("1ï¸âƒ£ Create user...")
        user_data = {"email": "test@example.com", "full_name": "Test User"}
        resp = client.post("/users/", json=user_data)
        print(f"   POST /users/ -> {resp.status_code}: {resp.text}")

        assert resp.status_code in [200, 201], f"Create failed: {resp.status_code} - {resp.text}"
        data = resp.json()
        assert "id" in data and data["email"] == "test@example.com"
        user_id = data["id"]
        print(f"   User created: {user_id}")

        # 2. List users
        print("\n2ï¸âƒ£ List users...")
        resp = client.get("/users/")
        print(f"   GET /users/ -> {resp.status_code}")

        assert resp.status_code == 200, f"List failed: {resp.status_code} - {resp.text}"
        users = resp.json()
        assert isinstance(users, list) and len(users) == 1
        print(f"   Found {len(users)} users")

        # 3. Get user
        print(f"\n3ï¸âƒ£ Get user {user_id}...")
        resp = client.get(f"/users/{user_id}")
        print(f"   GET /users/{user_id} -> {resp.status_code}")

        assert resp.status_code == 200, f"Get failed: {resp.status_code} - {resp.text}"
        user_data_retrieved = resp.json()
        assert user_data_retrieved["id"] == user_id
        print("   User retrieved")

        # 4. Delete user
        print(f"\n4ï¸âƒ£ Delete user {user_id}...")
        resp = client.delete(f"/users/{user_id}")
        print(f"   DELETE /users/{user_id} -> {resp.status_code}")

        assert resp.status_code in [200, 204], f"Delete failed: {resp.status_code} - {resp.text}"
        print("   User deleted")

        # 5. Try to delete again (404)
        print(f"\n5ï¸âƒ£ Try delete again...")
        resp = client.delete(f"/users/{user_id}")
        print(f"   DELETE /users/{user_id} -> {resp.status_code}")

        assert resp.status_code == 404, f"Expected 404, got {resp.status_code}"
        print("   Correctly returns 404")

        # 6. Try get deleted user (404)
        print(f"\n6ï¸âƒ£ Try get deleted user...")
        resp = client.get(f"/users/{user_id}")
        print(f"   GET /users/{user_id} -> {resp.status_code}")

        assert resp.status_code == 404, f"Expected 404, got {resp.status_code}"
        print("   Correctly returns 404")

        print("\nAll CRUD tests successful!")


    finally:
        try:
            if test_db_file.exists():
                test_db_file.unlink()
                print(f"ğŸ§¹ Cleaned up test database: {test_db_file}")
        except PermissionError:
            print(f"âš ï¸  Could not delete {test_db_file} (file in use)")
            pass
